#!/usr/bin/env bash
# plugin_manager.sh - oh-my-bash-like minimal plugin manager for bash_functions.d
# Plugins are directories under ~/.bash_functions.d/plugins/<name>
# Each plugin can have: init.sh (sourced), bin/ (executables), docs/

set -euo pipefail
PLUGINS_DIR="$HOME/.bash_functions.d/plugins"
ENABLED_ENV="$HOME/.bash_functions.d/plugins/enabled_env.sh"
mkdir -p "$PLUGINS_DIR"

usage(){
  cat <<EOF
plugin_manager.sh [install|remove|list|enable|disable|regen] <plugin> [git-url] [--apply]

install <name> <git-url>  clone plugin into plugins/<name>
remove <name>             remove plugin dir
list                      list installed plugins
enable <name>             create symlink into enabled/, register bin, and regenerate enabled_env
    --apply                print shell snippet to eval to source enabled_env in current shell
disable <name>            remove enabled symlink and unregister bin
regen                     regenerate enabled_env from currently enabled plugins
EOF
}

# helper to add plugin bin to managed PATH
register_plugin_bin(){
  local name="$1"
  local bin="$PLUGINS_DIR/$name/bin"
  if [[ -d "$bin" ]]; then
    if [[ -x "$HOME/.bash_functions.d/path_manager.sh" ]]; then
      bash "$HOME/.bash_functions.d/path_manager.sh" add "$bin" 2>/dev/null || true
    else
      mkdir -p "$HOME/.bash_functions.d"
      # avoid duplicate entries
      grep -Fxq "$bin" "$HOME/.bash_functions.d/path.env" 2>/dev/null || echo "$bin" >> "$HOME/.bash_functions.d/path.env"
    fi
  fi
}

# helper to unregister plugin bin
unregister_plugin_bin(){
  local name="$1"
  local bin="$PLUGINS_DIR/$name/bin"
  if [[ -d "$bin" ]]; then
    if [[ -x "$HOME/.bash_functions.d/path_manager.sh" ]]; then
      bash "$HOME/.bash_functions.d/path_manager.sh" remove "$bin" 2>/dev/null || true
    else
      if [[ -f "$HOME/.bash_functions.d/path.env" ]]; then
        grep -Fxv "$bin" "$HOME/.bash_functions.d/path.env" > "$HOME/.bash_functions.d/path.env.tmp" && mv "$HOME/.bash_functions.d/path.env.tmp" "$HOME/.bash_functions.d/path.env" || true
      fi
    fi
  fi
}

# regenerate enabled_env.sh by iterating enabled plugins and writing PATH prepends and source lines
regenerate_enabled_env(){
  mkdir -p "$(dirname "$ENABLED_ENV")"
  tmpf=$(mktemp)
  echo "# Auto-generated by plugin_manager.sh - do not edit" > "$tmpf"
  echo "# Generated: $(date -u)" >> "$tmpf"
  echo "" >> "$tmpf"
  # collect bin dirs to prepend
  echo "# Prepend plugin bin dirs to PATH" >> "$tmpf"
  echo "_BFD_PLUGIN_PATHS=()" >> "$tmpf"
  if [[ -d "$PLUGINS_DIR/enabled" ]]; then
    for d in "$PLUGINS_DIR/enabled"/*; do
      [[ -d "$d" ]] || continue
      pbin="$d/bin"
      if [[ -d "$pbin" ]]; then
        echo "_BFD_PLUGIN_PATHS+=(\"$pbin\")" >> "$tmpf"
      fi
    done
  fi
  printf '%s
' 'for _p in "${_BFD_PLUGIN_PATHS[@]}"; do' >> "$tmpf"
  printf '%s
' '  case ":$PATH:" in' >> "$tmpf"
  printf '%s
' '    *:$_p:*) ;;' >> "$tmpf"
  printf '%s
' '    *) PATH="$_p:$PATH" ;;' >> "$tmpf"
  printf '%s
' '  esac' >> "$tmpf"
  printf '%s
' 'done' >> "$tmpf"
  echo "export PATH" >> "$tmpf"
  echo "" >> "$tmpf"
  # source init scripts
  echo "# Source plugin init scripts if present" >> "$tmpf"
  if [[ -d "$PLUGINS_DIR/enabled" ]]; then
    for d in "$PLUGINS_DIR/enabled"/*; do
      [[ -d "$d" ]] || continue
      init="$d/init.sh"
      if [[ -f "$init" ]]; then
        # source only when the file exists
        echo "# plugin: $(basename "$d")" >> "$tmpf"
        echo "if [[ -f \"$init\" ]]; then" >> "$tmpf"
        echo "  # shellcheck disable=SC1090" >> "$tmpf"
        echo "  source \"$init\"" >> "$tmpf"
        echo "fi" >> "$tmpf"
        echo "" >> "$tmpf"
      fi
    done
  fi
  mv "$tmpf" "$ENABLED_ENV"
  chmod 644 "$ENABLED_ENV"
}

case ${1:-help} in
  install)
    if [[ -z "${2:-}" || -z "${3:-}" ]]; then echo "usage: plugin_manager.sh install <name> <git-url>"; exit 2; fi
    name="$2"; url="$3"
    git clone "$url" "$PLUGINS_DIR/$name"
    echo "Installed $name"
    ;;
  remove)
    if [[ -z "${2:-}" ]]; then echo "usage: plugin_manager.sh remove <name>"; exit 2; fi
    name="$2"
    unregister_plugin_bin "$name"
    if [[ -z "${name:-}" ]]; then echo "plugin name required"; exit 2; fi
    rm -rf "${PLUGINS_DIR:?}/$name"
    echo "Removed $name"
    regenerate_enabled_env
    ;;
  list)
    ls -la "$PLUGINS_DIR"
    ;;
  enable)
    if [[ -z "${2:-}" ]]; then echo "usage: plugin_manager.sh enable <name> [--apply]"; exit 2; fi
    name="$2"
    APPLY=0
    if [[ "${3:-}" == "--apply" ]]; then APPLY=1; fi
    mkdir -p "$PLUGINS_DIR/enabled"
    ln -sfn "$PLUGINS_DIR/$name" "$PLUGINS_DIR/enabled/$name"
    # register the bin dir so shells pick it up
    register_plugin_bin "$name"
    echo "Enabled $name"
    regenerate_enabled_env
    if [[ $APPLY -eq 1 ]]; then
      echo "To apply in your current shell run (or eval):"
      echo "  source '$ENABLED_ENV'"
    else
      echo "To apply to your shell, add to your ~/.bashrc or run:\n  source '$ENABLED_ENV'"
    fi
    ;;
  disable)
    if [[ -z "${2:-}" ]]; then echo "usage: plugin_manager.sh disable <name>"; exit 2; fi
    name="$2"
    rm -f "$PLUGINS_DIR/enabled/$name" || true
    unregister_plugin_bin "$name"
    echo "Disabled $name"
    regenerate_enabled_env
    ;;
  regen)
    regenerate_enabled_env
    echo "Regenerated $ENABLED_ENV"
    ;;
  *) usage;;
esac
